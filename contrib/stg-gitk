#!/bin/sh
set -e

# stg-gitk - helper script to graphically display an StGIT stack

# Displays given branches and stacks, without getting disturbed by
# patch logs.

# LIMITATIONS:
# - no support for spaces in branch names

# Copyright (c) 2007 Yann Dirson <ydirson@altern.org>
# Subject to the GNU GPL, version 2.

usage()
{
    echo "Usage: $(basename $0) [<branches>|--all]"
    exit 1
}

allbranches=0
refsonly=0
while [ "$#" -gt 0 ]; do
    case "$1" in
	--refs) refsonly=1 ;;
	--all) allbranches=1 ;;
	--*) usage ;;
	*) break ;;
    esac
    shift
done

if [ $allbranches = 1 ] && [ "$#" -gt 0 ]; then
    usage
fi

GIT_DIR=$(git-rev-parse --git-dir)
GIT_DIR_SPKIPLEN=$(printf "$GIT_DIR/X" | wc -c)

refdirs=''
if [ $allbranches = 1 ]; then
    refdirs="$GIT_DIR/refs"
else
    if [ "$#" = 0 ]; then
	set -- "$(stg branch)"
    fi

    for b in "$@"; do
	if [ -e "$GIT_DIR/refs/patches/$b" ]; then
	    # StGIT branch: show all patches
	    refdirs="$refdirs $GIT_DIR/refs/heads/$b $GIT_DIR/refs/patches/$b"
	elif [ -e "$GIT_DIR/refs/heads/$b" ]; then
	    # other GIT branch
	    refdirs="$refdirs $GIT_DIR/refs/heads/$b"
	elif [ $(git-for-each-ref "refs/$b" | wc -l) != 0 ]; then
	    # other ref
	    refdirs="$refdirs $(git-for-each-ref --format="$GIT_DIR/%(refname)" "refs/$b")"
	else
	    echo >&2 "ERROR: no such ref '$b'"
	    usage
	fi
    done
fi

printrefs()
{
    find $refdirs -type f -not -name '*.log' | cut -c${GIT_DIR_SPKIPLEN}-
}

if [ $refsonly = 1 ]; then
    printrefs
elif grep -q -- --argscmd $(which gitk); then
    # This gitk supports --argscmd.
    # Let's use a hack to pass --all, which was consumed during command-line parsing
    if [ $allbranches = 1 ]; then
	gitk --argscmd="$0 --refs --all"
    else
	gitk --argscmd="$0 --refs $*"
    fi
else
    # This gitk does not support --argscmd, just compute refs onces
    gitk $(printrefs)
fi
