
__copyright__ = """
Copyright (C) 2005, Catalin Marinas <catalin.marinas@gmail.com>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License version 2 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
"""

import sys, os
from stgit.argparse import opt
from stgit.commands.common import *
from stgit.utils import *
from stgit.out import *
from stgit import stack, git
from stgit.config import config

help = 'Generate a new commit for the current patch'
kind = 'patch'
usage = ['[options] [<files or dirs>]']
description = """
Include the latest tree changes in the current patch. This command
generates a new GIT commit object with the patch details, the previous
one no longer being visible. The '--force' option is useful
when a commit object was created with a different tool
but the changes need to be included in the current patch."""

options = [
    opt('-f', '--force', action = 'store_true',
        short = 'Force the refresh even if HEAD and top differ'),
    opt('--update', action = 'store_true',
        short = 'Only update the current patch files'),
    opt('--index', action = 'store_true',
        short = 'Refresh from index instead of worktree', long = """
        Instead of setting the patch top to the current contents of
        the worktree, set it to the current contents of the index."""),
    opt('--undo', action = 'store_true',
        short = 'Revert the commit generated by the last refresh'),
    opt('-a', '--annotate', metavar = 'NOTE',
        short = 'Annotate the patch log entry'),
    opt('-p', '--patch',
        short = 'Refresh (applied) PATCH instead of the top patch')]

directory = DirectoryHasRepository(log = True)

def func(parser, options, args):
    """Generate a new commit for the current or given patch.
    """
    args = git.ls_files(args)
    directory.cd_to_topdir()

    autoresolved = config.get('stgit.autoresolved')
    if autoresolved != 'yes':
        check_conflicts()

    if options.patch:
        if args or options.update:
            raise CmdException, \
                  'Only full refresh is available with the --patch option'
        patch = options.patch
        if not crt_series.patch_applied(patch):
            raise CmdException, 'Patches "%s" not applied' % patch
    else:
        patch = crt_series.get_current()
        if not patch:
            raise CmdException, 'No patches applied'

    if options.index:
        if args or options.update:
            raise CmdException, \
                  'Only full refresh is available with the --index option'
        if options.patch:
            raise CmdException, \
                  '--patch is not compatible with the --index option'

    if not options.force:
        check_head_top_equal(crt_series)

    if options.undo:
        out.start('Undoing the refresh of "%s"' % patch)
        crt_series.undo_refresh()
        out.done()
        return

    if not options.index:
        files = [path for (stat, path) in git.tree_status(files = args, verbose = True)]

    if options.index or files or not crt_series.head_top_equal():
        if options.patch:
            applied = crt_series.get_applied()
            between = applied[:applied.index(patch):-1]
            pop_patches(crt_series, between, keep = True)
        elif options.update:
            rev1 = git_id(crt_series, 'HEAD^')
            rev2 = git_id(crt_series, 'HEAD')
            patch_files = git.barefiles(rev1, rev2).split('\n')
            files = [f for f in files if f in patch_files]
            if not files:
                out.info('No modified files for updating patch "%s"' % patch)
                return

        out.start('Refreshing patch "%s"' % patch)

        if autoresolved == 'yes':
            resolved_all()

        if options.index:
            crt_series.refresh_patch(cache_update = False,
                                     backup = True, notes = options.annotate)
        else:
            crt_series.refresh_patch(files = files,
                                     backup = True, notes = options.annotate)

        if crt_series.empty_patch(patch):
            out.done('empty patch')
        else:
            out.done()

        if options.patch:
            between.reverse()
            push_patches(crt_series, between)
    elif options.annotate:
        # only annotate the top log entry as there is no need to
        # refresh the patch and generate a full commit
        crt_series.log_patch(crt_series.get_patch(patch), None,
                             notes = options.annotate)
    else:
        out.info('Patch "%s" is already up to date' % patch)
